{"./":{"url":"./","title":"前言","keywords":"","body":"学习新事物，我觉得得知道她的一些属性，比如是什么，能解决什么问题，来自哪里等等。没有最好的，只有最合适的。接下来的日子或者说岁月里，就来浅谈 Nodejs。 是什么 正如 Node.js 官方所说 Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. 即 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。可以看出 Node.js 不是一门新的编程语言，而是 JavaScript 的运行环境（服务端的运行环境，之如客户端的浏览器环境），而 Nodejs 的编程语言指的是 JavaScript（这之间的关系还是要梳理清楚）。 2009 年之前，当时的 JavaScript 还是一个在浏览器环境里的一门脚本语言，实现前端页面交互和一些动态特效。时间的分水岭就在这里，Javascript 就不只运行于浏览器，还可以运行于服务端，仿佛打通了前后端的任督二脉，这要归功于 Node.js 之父 Ryan Dahl。 为什么选 Javascript JavaScript 是一个单线程的语言，单线程的优点是不会像 Java 这些多线程语言在编程时出现线程同步、线程锁问题，同时也避免了上下文切换带来的性能开销问题。想象一下多线程对同一个 DOM 进行操作会怎样？不是乱套了吗？可能你会想一个问题：单线程是不是前面一个执行不完，后面就被卡住了？ JavaScript 是一种采用了事件驱动、异步回调的模式（主线程是单线程）。JavaScript 在虚拟机上由于有了 Chrome V8 的支持，使得 JavaScript 成为了 Node.js 的首选语言。所以，Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 架构 首先，Node.js 由 Libuv、Chrome V8、一些核心 API 构成，如图所示： Node Standard Library：Node.js 的标准库，对外提供的 JavaScript 接口，如 http、buffer、fs、stream 等; Node bindings：是 JavaScript 与 C++ 连接的桥梁，对下层模块进行封装，向上层提供基础的 API 接口; V8：Google 开源的高性能 JavaScript 引擎，使用 C++ 开发，应用于谷歌浏览器； Libuv：是一个跨平台的支持事件驱动的 I/O 库，使用 C 和 C++ 语言开发； C-ares：一个异步 DNS 解析库； Low-Level Components：提供了 http 解析、OpenSSL、数据压缩（zlib）等功能； 特点 跨平台 最初 Node.js 只运行于 Linux 平台，V0.6.0 版本后在 Libuv 的加持下可运行在 Windows 平台 单线程 使用单线程运行，不像 Apache HTTP 之类的服务器，每发生一个请求就产生一个线程。这种方法避免了 CPU 上下文切换和内存中的大量执行堆栈，解决了 Nginx 和其它服务器的 “上一个 10 年，著名的 C10K 并发连接问题”。 非阻塞 I/O 避免了等待输入或输出（文件系统、Web服务器、数据库等）响应造成的 CPU 时间损失，得益于 Libuv 的异步 I/O。 事件驱动 事件与回调在 JavaScript 中屡见不鲜，是一种高性能的服务模型，对于习惯同步思路编程的同学一时很难理解。Node.js 与 Nginx 均是基于这种方式，只是 Nginx 采用 C 编写，适用于 Web 服务器，Node.js 是可扩展、高性能的平台。 场景 I/O 密集型场景 Node.js 的特点就是事件驱动，非阻塞异步 I/O，只开一个主线程，不会每个请求都去创建一个线程，从而节省资源开销。 Resutful API 使用 Node.js 来做为中间层，整合数据并提供 API 接口，这些数据源一般来自第三方接口或者数据库，后端就可以更专注于业务开发。推荐一个去哪儿开源的 API 管理工具 YAPI，就是使用的 Node.js 进行开发的。 BFF Backend For Frontend（服务于前端的后端），逻辑上的分层并不是新技术。可做一些资源的整合。场景是：原先需要从多个地方获取数据，有了这一层（做个聚合），统一处理之后返回一个数据源，同时后期也不会因为后端数据迁移而重构。 RPC Remote Procedure Call（远程过程调用）。当今微服务模式下，主要是针对功能或业务进行服务化，服务间的通信常见的模式都是通过 HTTP 实现，HTTP 属于应用层协议，如果通过 TCP 的方式（传输层），那岂不是更高效。RPC 服务就是采用的 TCP，比如 Google 的 gRPC、阿里的 Dubble。 基础工具 比如编译器、构建工具、搭建脚手架等，我们知道的 Gulp、Webpack 就是成功案例。 论坛社区 Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统，界面优雅，功能丰富，小巧迅速，已在Node.js 中文技术社区 CNode 得到应用，但你完全可以用它搭建自己的社区。 Serverless 无服务器架构，开发者只需关注于业务本身，不需要去关心运维、流量处理这些工作。我们知道 JavaScript 中函数是一等一的公民，写个函数就实现一个 API 接口给到前端，对开发工作减轻很多（函数即服务）。 Microservices 微服务，小型服务、以独立进程运行、可使用不同语言。根据业务形态来选择不同的语言实现，Node.js 本身也是很轻量级的，实现起来也很快。最好的打不过合适的！ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"npm.html":{"url":"npm.html","title":"npm 包管理工具","keywords":"","body":"npm 包管理工具 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"module.html":{"url":"module.html","title":"Module 模块","keywords":"","body":"采用了 Commonjs 规范，通过 module.exports、require 来导出和导入模块。模块加载机制中，采用了延迟加载的策略。就是说在用到的情况下，系统模块才会被加载，等加载完成后会放到 binding_cache 中。 分类（模块类型） 系统模块 核心模块（native 模块），http、buffer、fs 等，底层调用的内建模块 (C/C++)； C/C++ 模块（built-in 内建模块），供 native 模块调用； 第三方模块 第三方维护的模块，比如 express、koa、moment.js 等； 本地维护的模块（以路径形式的文件模块）比如 .、..、/ 开头的; 文件形式 javaScript 模块，module.js； json 模块，module.json； C/C++ 模块，编译后扩展名为 .node，module.node； 加载机制 加载步骤 经历 路径分析、文件定位和编译执行。 加载顺序 系统缓存，一个模块被执行后会被缓存起来，提高再次加载速度； 系统模块，即原生模块，部分核心模块已经被编译成二进制，省略了 路径分析、文件定位，会直接被加载到了内存中，其中系统模块定义在源码的 lib 目录下； 文件模块，优先加载 .、..、/ 开头的，会依次按照 .js、.json、.node 进行扩展名补足尝试（文件没有加上扩展名），最好还是加上文件的扩展名。 目录模块，文件模块加载过程中，没有找到，但发现一个同样的目录名，就会将这个目录当作一个包来处理。这块采用了 Commonjs 规范，在文件 package.json 中查找； node_module 模块，如果系统模块、路径文件模块都找不到，Node.js 会从当前模块的父目录开始查找，直到系统的根目录； 关于缓存问题 模块缓存后，可以通过 require.cache 查看已缓存的模块。 // 模块文件 require.module.js module.exports = { name: 'pr', say(){ } } // 引用模块文件 require.cache.js require('./require.module'); console.log('require.cache ----- '); console.log(require.cache); 对象引用 1.exports 与 module.exports 关系 const exports = module.exports; 所以就不能改变 exports 的指向，可以这样 exports.info = { name: 'pr', age: 30 } module.exports = { name: 'pr', age: 30 } 模块循环引用 模块 moduleA.js 和 moduleB.js 两个模块互相引用，会怎样？ // moduleA.js console.log('模块 moduleA'); exports.name = 'moduleA name'; age = 27; const moduleB = require('./moduleB.js'); console.log('moduleA require moduleB =>', moduleB.name); // moduleB.js console.log('模块 moduleB'); exports.name = 'moduleB name'; const moduleA = require('./moduleA.js'); console.log('moduleB require moduleA =>', moduleA.name); 启动模块 node moduleA.js，会打印 模块 moduleA； 模块 moduleA.js 中加载 moduleB.js，打印 模块 moduleB； 模块 moduleB.js 中又加载 moduleA.js，此时模块 moduleA.js 还没有执行完，返回模块 moduleA.js 的 exports 对象给到模块 moduleB.js； 模块 moduleB.js 加载完后，其中有个 moduleA.js 中挂载了全局的变量 age，所以能打印出来，最后将模块 moduleB.js 的 exports 对象给到模块 moduleA.js； 很有意思的是，在代码执行前，会用一个封装器将执行代码段封装起来 (function(exports, require, module, __filename, __dirname) { // something }); 本次代码 Github 你可以... 上一篇：Node.js 这一次不再错过 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"console.html":{"url":"console.html","title":"Console 日志模块","keywords":"","body":"Console 日志模块提供了调试功能，测试调试中使用很方便、也用的最多的。它和浏览器中的 console 类似。 造轮子日志模块 Log 初始化 Log 对象； 参数校验：当前对象是否为 Log 实例（安全模式），是否为可写流实例； 为 Log 对象定义 stdout，stderr 等属性； 将原型方法上的属性绑定到 Log 实例上； 实现 log、error、warning、trace、clear 等方法； 编码 // log.js const util = require('util'); /** * 初始化对象 Log * @param {*} stdout * @param {*} stderr */ function Log(stdout, stderr) { // 安全模式，检查当前对象是否是 Log 的实例 if (!(this instanceof Log)) { return new Log(stdout, stderr); } // 检查是否是可写流实例 if (!stdout || !(stdout.write instanceof Function)) { throw new Error('可写流实例不存在'); } // stderr 未指定就指定 stdout if (!stderr) { stderr = stdout; } let props = { writable: true, enumerable: false, configurable: false } // 定义属性 _stdout Object.defineProperty(this, '_stdout', Object.assign(props, { value: stdout })); // 定义属性 _stderr Object.defineProperty(this, '_stderr', Object.assign(props, { value: stderr })); // 定义属性 _times Object.defineProperty(this, '_time', Object.assign(props, { value: new Map() })); // 将原型上的方法绑定到 Log 实例上 const keys = Object.keys(Log.prototype); for (let key in keys) { const item = keys[key]; this[item] = this[item].bind(this); } } // 定义原型上的方法 Log.prototype.info = function () { this._stdout.write(util.format.apply(this, arguments) + '\\n'); } Log.prototype.log = Log.prototype.info; Log.prototype.error = function () { this._stderr.write(util.format.apply(this, arguments) + '\\n'); } Log.prototype.warn = Log.prototype.error; // 堆栈信息 Log.prototype.trace = function trace(...args) { const err = { name: 'Trace', message: util.format.apply(null, args) }; // V8 引擎的 Stack Trace API Error.captureStackTrace(err, trace); this.error(err.stack); } // 输出某个对象 Log.prototype.dir = function (object, options) { options = Object.assign({ customInspect: false }, options); this._stdout.write(util.inspect(object, options) + '\\n'); } // 计时器 Log.prototype.time = function(label){ // this._time 是一个 Map this._time.set(label, process.hrtime()); } Log.prototype.timeEnd = function(label){ const timeLabel = this._time.get(label); if(!timeLabel) { process.emitWarning(`没有时间标志 ${label}`); return } const duration = process.hrtime(timeLabel); const ms = duration[0] * 1000 + duration[1] / 1e6; this.log('标签%s: 耗时 %sms', label, ms.toFixed(3)); this._time.delete(label); } // 清除控制台信息 Log.prototype.clear = function () { if (this._stdout.isTTY) { const { cursorTo, clearScreenDown } = require('readline'); cursorTo(this._stdout, 0, 0); // 光标移到 TTY stream 指定位置 clearScreenDown(this._stdout); // 从光标的当前位置向下清除给定的 TTY 流 } } const stdout = process.stdout; const stderr = process.stderr; module.exports = new Log(stdout, stderr); module.exports.Log = Log; 实例 // log.demo.js const log = require('./log.js'); const fs = require('fs'); const { Log } = require('./log.js'); const stdout = fs.createWriteStream('./stdout.txt'); const stderr = fs.createWriteStream('./stderr.txt'); const obj = { name: 'pr', age: 30, favorite: { 'ball': ['篮球', '足球'] } } // 日志输出至终端 log.log('打印日志'); log.info('打印基础日志'); log.error('打印错误日志'); log.warn('打印警告日志'); log.trace('打印错误堆栈'); // 打印对象 log.log(obj); log.dir(obj, { depth: 0 }); // 程序执行消耗时间 log.time('定时器 pr'); for (let i = 0; i 本次代码 Github 面试题 面试之道之 Node.js 日志模块 console console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}